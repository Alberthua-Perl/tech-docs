# 1. 数据和 C

## 文档目录
- [1. 数据和 C](#1-数据和-c)
  - [文档目录](#文档目录)
  - [文档说明](#文档说明)
  - [1. 整数类型及其取值范围](#1-整数类型及其取值范围)
  - [2. char 类型](#2-char-类型)
  - [3. \_Bool 类型](#3-_bool-类型)
  - [💪 4. 扩展的整数类型：`stdint.h` 与 `inttypes.h`](#-4-扩展的整数类型stdinth-与-inttypesh)
  - [5. 浮点数类型](#5-浮点数类型)
  - [🧬 6. 整数溢出分析](#-6-整数溢出分析)
  - [📚 7. 总结](#-7-总结)
  - [8. 参考链接](#8-参考链接)

## 文档说明

此文档作为重要知识点的学习记录，如需查看完整内容请翻阅《C Primer Plus（第六版）中文版》原书。

## 1. 整数类型及其取值范围

- short、int（16 bit）：`-32768 ~ 32767`
- int、long（32 bit）：`-2147483648 ~ 2147483647`
- long long（64 bit）：`-9223372036854775808 ~ 9223372036854775807`
- unsigned short, int（16 bit）：`0 ~ 65535`
- unsigned int, long（32 bit）：`0 ~ 4294967295`
- unsigned long long（64 bit）：`0 ~ 18446744073709551616`

> 🚨 注意：
> 
>  1. 整数类型的取值范围会根据不同硬件架构的改变而发生变化，可使用 sizeof 内置运算符确定特定环境中的取值范围。
>  2. 位（bit）是寄存器支持的位数

- 🚀 使用多种整数类型的原因：由于不同计算机的自然字长不同，可存储使用的整数类型不尽相同，为了兼容不同的字长，在跨平台架构的计算机或硬件上运行 C 语言程序，因此引入多种整数类型。
- C 语言编译器识别整数类型的顺序：`int`、`unsigned int`、`long`、`unsigned long`、`long long`、`unsigned long long`
- 各类整数类型的打印方式（printf() 函数打印）：
  - `int` 关键字与 short 或 long 一起使用时可省略，单独声明整数类型时不可省略。
  - 转换说明的常用修饰符：d、x、o、u、h、l、ll
  - 有符号类型（signed）：
    - `signed` 关键字默认省略，在任何有符号类型前面添加时，可强调使用有符号类型的意图。
    - short：
      - short 与 signed short int 或 short int 等效
      - `%hd` 转换说明：十进制显示 short 类型整数
      - `%hx` 转换说明：十六进制显示 short 类型整数
      - `%ho` 转换说明：八进制显示 short 类型整数
    - int 或 long：
      - int 与 signed int 等效
      - long 与 signed long int 或 long int 等效
      - `%d` 转换说明：十进制显示 int 或 long 类型整数（若系统中 int 与 long 的大小相同）
      - `%lx` 转换说明：十六进制显示 long 类型整数
      - `%lo` 转换说明：八进制显示 long 类型整数

      > 注意：有时需要编译器以 long 类型存储一个小数字，可在声明定义值的末尾加上 `l` 或 `L` 后缀，如 5L、0x10LL、6ull 等。

    - long long：
      - long long 与 signed long long int 或 long long int 等效
      - `%lld` 转换说明：十进制显示 long long 类型整数
  - 无符号类型（unsigned）：
    - 使用 `%u` 转换
    - `h` 与 `l` 前缀都可以和 `u` 一起使用
    - `%lu` 转换说明：unsigned long 类型整数
    - `%llu` 转换说明：unsigned long long 类型整数

## 2. char 类型

- char 类型用于存储字符，但从技术层面看，char 是整数类型，其储存的是整数而不是字符。
- char 关键字声明字符常量（character constant），将 1 字节（8 bits）定义为 char 类型占用的位（bit）数。
- 标准 ASCII 码的范围是 `0~127`，只需 `7` 位二进制数即可表示，因此 char 类型容纳标准 ASCII 码绰绰有余。
- 使用单引号圈引字符声明字符常量，不可使用双引号圈引，否则将其视为字符串。
- 字符以数值形式存储，因此也可用数字代码值来赋值。
- 💥 请注意，C 语言将字符常量视为 `int` 类型而非 `char` 类型。
- 非打印字符的表示：
  - 使用 ASCII 码表示非打印字符，如蜂鸣的 ASCII 值为 7。
  - 使用转义序列（escape sequence）表示非打印字符

  > C90 标准中的活跃位置（active position）：指的是显示设备中下一个字符将出现的位置，即平时常说的屏幕光标位置

- ✨ char 类型字符常量可使用十进制、八进制与十六进制表示，但必须使用转义序列表示八进制与十六进制整数值。
- `printf()` 函数使用 `%c` 转换说明打印字符常量，也可使用 `%d`、`%#o` 或 `%#x` 等转换说明将其转换为十进制、八进制与十六进制打印。其中转换说明决定了数据的显示方式，而非数据的储存方式。
- 可根据编译器手册确认是否可使用有符号类型（`signed char`）或无符号类型（`unsigned char`），或查阅 `/usr/include/limits.h` 头文件。
- signed char 的取值范围为 `-128~127`，而 unsigned char 的取值范围为 `0~255`。

## 3. _Bool 类型

- C99 标准中新添加的类型，用于表示布尔值，即 true 或 false。
- _Bool 类型使用 1 表示 true，而 0 表示 false，因此其实际是一种 unsigned int 类型，仅占 1 位存储空间。
- 程序通过布尔值可选择执行哪部分代码。

## 💪 4. 扩展的整数类型：`stdint.h` 与 `inttypes.h`

- C 语言提供了众多标准规定的整数类型，但有些类型名在不同的系统上功能不同。为了使 C 语言的类型在各系统中功能相同，C99 新增 `stdint.h` 与 `inttypes.h` 头文件。
- ✨ 可移植类型（或扩展的整数类型）可使各系统上的 int 或 long 类型定义为相同的类型名，也称为类型别名。
- 类型别名的分类：
  - 精确宽度整数类型（exact-width integer type）：如 `int32_t` 指 32 位有符号整数类型的别名
  - 最小宽度类型（minimum width type）：如 `int_least8_t` 指至少 8 位有符号整数类型的别名
  - 最快最小宽度类型（fastest minimum width type）：如 `int_fast8_t` 指至少 8 位有符号且运算最快的整数类型的别名
  - 最大整数类型：`intmax_t` 可储存任何有效的有符号整数，`uintmax_t` 可储存最大的无符号整数。

  > 注意：以上两类可能比 long long 与 unsigned long long 类型更大

- 此部分可参看原书 "附录 B.6 参考资料 VI：扩展的整数类型"。

## 5. 浮点数类型

- 浮点数也称为浮点型常量
- 浮点数表示法：一般计数法、科学计数法、e 计数法（计算机中的表示）、p 计数法（十六进制表示）
- 浮点数分类：
  - `float` 类型（单精度）：
    - 存储占用位数：32 位
    - 有效位数：至少 6 位有效数字
    - 取值范围：至少 $10^{-37}$ ~ $10^{+37}$
  - `double` 类型（双精度）：
    - 存储占用位数：64 位
    - 有效位数：至少 10 位有效数字
    - 取值范围：至少 $10^{-37}$ ~ $10^{+37}$

    > 注意：float 类型在输出时将自动转换为 double 类型

  - `long double` 类型
- 浮点数运算：
  - ✨ 默认情况下，编译器将浮点型常量视为 double 类型精度（双精度）。因此，若使用 4.0 与 2.0 进行乘法运算时，它们都被储存为 64 位的双精度类型，乘积运算后再被截断为 float 类型。
  - 在浮点型常量后面加上 `f` 或 `F` 后缀以显示的方式指定为 float 类型而非默认的 double 类型，如 2.3f 和 9.11E9F 等。
- 浮点数打印（printf() 函数打印）：  
  - `%f` 转换说明：打印十进制计数法的浮点数
  - `%e` 或 `%E` 转换说明：打印指数计数法的浮点数（指数部分分别用 e 或 E 表示）
  - `%a` 转换说明：打印十六进制格式的浮点数
  - `%Lf`、`%Le`、`%LE` 或 `%La` 转换说明：打印 long double 类型的浮点数
- 浮点数的上溢与下溢：
  - 上溢（overflow）：当浮点数计算，而计算的值超出当前类型表达的最大范围时，即发生上溢。这种情况下，该值表示无穷大的特定值，显示为 `inf` 或 `infinity`。
  - 下溢（underflow）：当浮点数计算，而在计算的过程中损失了原末尾有效位上的数字，即发生下溢。

## 🧬 6. 整数溢出分析

整数的表示可分为有符号整数（signed integer）与无符号整数（unsigned integer），在各类整数取值过程中，若超出取值范围的上限将出现**上溢（overflow）**。如下程序所示：

```c
/* ctm_int_overflow.c - 超出系统上的最大整数值 (整形溢出测试) */
#include <stdio.h>

int main(void)
{
    int i = 2147483647;  /* int 类型变量的最大值 */
    unsigned long j = 4294967295;  /* long 类型变量的最大值 */

    printf("%d %d %d\n", i, i+1, i+2);
    /* 输出为：2147483647 -2147483648 -2147483647
       值超出最大取值范围将溢出至起始点 -2147483648 */
    printf("%u %u %u\n", j, j+1, j+2);
    /* 输出为：4294967295 0 1 */
    return 0;
}
```

> 说明：
> 
> 上述现象被称为 **整数溢出（integer overflow）**。
> 
> 在 C 语言中：
> - 有符号整数溢出：当运算结果超出类型的表示范围时，行为是 **未定义的（undefined behavior）**。但在大多数现代系统中，使用补码表示，结果会 “环绕” 到最小值。
> - 无符号整数溢出：结果是明确定义的，会按模 2^n 环绕。

在笔者的运行环境中 int 类型的变量占 4 字节（32 位），此类型的最大取值为 $2147483647_{10}$（$2^{31}-1$）。若在这个值的基础上再加 1，变为 $2147483648_{10}$（$2^{31}$），超出最大取值范围（发生上溢）。因此，运行此程序后 i+1 返回 $-2147483648_{10}$（$-2^{31}$）。那么，为何会产生这个有符号整数呢？可参考以下推导：

1️⃣ $2147483647_{10}$ 的原码 $0111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111_{2}$  (1)

2️⃣ 将 (1) 加 1（二进制加法）：

  ```plaintext   
    0111 1111 1111 1111 1111 1111 1111 1111  (1)
  + 0000 0000 0000 0000 0000 0000 0000 0001  (2)
  ----------------------------------------------
    1000 0000 0000 0000 0000 0000 0000 0000  (3)
  ```

  无符号整数（正整数）的原码最高位（符号位）为 0，有符号整数（负整数）的原码最高位（符号位）为 1。在计算机编码中，有符号整数统一使用 **二进制补码（two's complement）** 编码，正数补码即自身，负数补码为模 $2^{n}$ 下的同余类。因此，上式中的 (3) 是有符号整数 $-2147483648_{10}$ 的补码。

3️⃣ 手动验证 $-2147483648_{10}$ 的补码：
  - 32 位的模：$2^{32}$
  - 32 位的补码空间中，$2^{31}-1$（$2147483647_{10}$）的补码 $0111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111_{2}$
  - 32 位的补码空间中，$-2^{31}$（$-2147483648_{10}$）的补码 $1000\ 0000\ 0000\ 0000\ 0000\ 0000\ \ 0000_{2}$
  - 根据补码的性质：$[x]_{补}+[-x]_{补}=2^{n}$，其中 $x$ 为正整数，$n$ 为位数。
  - 因此，$[-2^{31}]_{补} = 2^{32} - 2^{31} = 2^{31} = 2147483648_{10}$，在 32 位空间中与 (3) 相同。

## 📚 7. 总结

- 由于计算机缺少足够的小数位来完成浮点数运算，因此在进行浮点数运算的时候可能发生浮点数计算结果的截断、上溢、下溢或舍入错误等。
- 整型数与浮点数混合运算时，整型数将转换成浮点数运算。
- C 语言的其他数据类型：数组、指针、结构、联合
- 本章重要函数包括 `printf()`、`scanf()`、`getchar()` 等，内置运算符包括 `sizeof`。

  > 注意：sizeof 内置运算符获取类型的大小必须使用 `()`，而获取某个量的大小 `()` 为可选。

- ✨ 函数的参数与陷阱：
  - 当前 C 语言通过函数原型机制检查函数调用时参数的个数与类型是否正确，但这种方式只针对于参数个数不变的函数有效。
  - 对于函数参数可变的 printf() 与 scanf() 函数无效，因此，在使用此类函数时需注意参数的个数与类型是否匹配正确，否则在不同平台上，编译器将给出不同的结果。
- 刷新缓冲区：
  - 从缓冲区（buffer）把数据发送到屏幕或文件被称为刷新缓冲区。
  - 💪 C 标准明确规定如何刷新缓冲区：缓冲区满、遇到换行字符、需要等待输入、调用 `fflush()` 函数。
  - 其中使用 scanf() 函数即为需要等待输入的情形，这迫使 printf() 函数将输出发送至屏幕上。

## 8. 参考链接

- [补码的计算方法](https://zhuanlan.zhihu.com/p/376848035)
- [彻底弄清：原码、反码、补码](https://blog.csdn.net/2401_83418369/article/details/141992473)
